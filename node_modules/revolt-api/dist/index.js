"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.API = exports.getPathName = void 0;
// This file was auto-generated by @insertish/oapi!
const axios_1 = __importDefault(require("axios"));
const lodash_defaultsdeep_1 = __importDefault(require("lodash.defaultsdeep"));
__exportStar(require("./types"), exports);
const baseURL_1 = require("./baseURL");
const params_1 = require("./params");
/**
 * Get the specific path name of any given path.
 * @param anyPath Any path
 * @returns Specific path
 */
function getPathName(anyPath) {
    const segments = anyPath.split('/');
    const list = params_1.pathResolve[(segments.length - 1).toString()] || [];
    for (const entry of list) {
        let i = 1;
        let copy = [...segments];
        for (i; i < segments.length; i++) {
            if (Array.isArray(entry[i - 1])) {
                copy[i] = entry[i - 1];
                continue;
            }
            else if (entry[i - 1] !== segments[i])
                break;
        }
        if (i === segments.length)
            return copy.join('/');
    }
}
exports.getPathName = getPathName;
/**
 * API Client
 */
class API {
    constructor({ baseURL, authentication } = {}) {
        this.baseURL = baseURL || baseURL_1.defaultBaseURL;
        this.authentication = authentication || {};
    }
    /**
     * Generate authentication options.
     */
    get auth() {
        if (this.authentication.rauth) {
            if (typeof this.authentication.rauth === 'string') {
                return {
                    headers: {
                        'X-Session-Token': this.authentication.rauth
                    }
                };
            }
        }
        else if (this.authentication.revolt) {
            switch (typeof this.authentication.revolt) {
                case 'string': {
                    return {
                        headers: {
                            'X-Bot-Token': this.authentication.revolt
                        }
                    };
                }
                case 'object': {
                    return {
                        headers: {
                            'X-Session-Token': this.authentication.revolt.token
                        }
                    };
                }
            }
        }
        return {};
    }
    /**
     * Generate config to pass through to API.
     */
    get config() {
        return Object.assign({ baseURL: this.baseURL }, this.auth);
    }
    /**
     * Send any arbitrary request.
     * @param method HTTP Method
     * @param path Path
     * @param params Body or Query Parameters
     * @param config Axios configuration
     * @returns Typed Response Data
     */
    req(method, path, params, config) {
        let query, body;
        let named = getPathName(path);
        // If we are aware of this route, then match the parameters given.
        if (named && typeof params === 'object') {
            const route = params_1.queryParams[named];
            const allowed_query = route[method];
            // Map each parameter to the correct object.
            for (const parameter of Object.keys(params)) {
                if (allowed_query === null || allowed_query === void 0 ? void 0 : allowed_query.includes(parameter)) {
                    query = Object.assign(Object.assign({}, (query || {})), { [parameter]: params[parameter] });
                }
                else {
                    body = Object.assign(Object.assign({}, (body || {})), { [parameter]: params[parameter] });
                }
            }
        }
        return (0, axios_1.default)(path, (0, lodash_defaultsdeep_1.default)({
            method,
            params: query,
            data: body
        }, (0, lodash_defaultsdeep_1.default)(config, this.config)))
            .then(res => res.data);
    }
    get(path, params, config) {
        // @ts-ignore-next-line
        return this.req('get', path, params, config);
    }
    patch(path, params, config) {
        // @ts-ignore-next-line
        return this.req('patch', path, params, config);
    }
    put(path, params, config) {
        // @ts-ignore-next-line
        return this.req('put', path, params, config);
    }
    delete(path, params, config) {
        // @ts-ignore-next-line
        return this.req('delete', path, params, config);
    }
    post(path, params, config) {
        // @ts-ignore-next-line
        return this.req('post', path, params, config);
    }
}
exports.API = API;
